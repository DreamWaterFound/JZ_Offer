# OFFER_005

## 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 

**NOTE** 给出的所有元素都大于0，若数组大小为0，请返回0。

## 初始信息
```
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray);
};
```

要求实现函数minNumberInRotateArray()。

## 实现的基本思想
一种是最简单的遍历思想。但是出这么一道题肯定不只是考你的简单遍历啊。

合适的解法是二分思想，应用的前提就是题目中给出的约束条件。
可以发现题目中给出的旋转数组可以认为是由两个部分组成的，前半部分是一个单调增数组，
后半部分也是一个单调增数组；并且前半个部分的数组所有元素的值一定大于等于（这里为了简化，先认为都是大于的）
后半部分的数组的，因此后半数组的第一个元素就是整个旋转数组的最小值。

基于此可以构建二分法的思想。先假设数组中没有重复的数字。设置两个指针p1,p2分别指向数组头尾；然后设置一个指向中间的指针mid。如果：

- \*mid\>\*p1 那么说明mid指向的是前一个数组中的元素，最小元素应该是在mid~p2之间，因此需要调整为p1=mid
- \*mid\<\*p1 那么说明mid指向的是后一个数组中的元素，最小元素应该是在p1~mid之间，因此需要调整为p2=mid

如果p2-p1==1那么说明此时p2已经指向了最小元素，算法结束。

接下来考虑数组中存在重复数字的情况。举个特例：

2 3 4 6 6 8 9

的一个旋转数组为

6 8 9 2 3 4 6

这个就造成了\*p1==\*p2的情况。不过对于这个例子而言，通过判断\*mid和\*p1 \*p2的大小依旧可以判断出
\*mid属于哪个数组。但是对于下面的情况：

2 2 2 2 2 1 2 以及 2 1 2 2 2 2 2

就无能为力了，无法判断。因此在这个时候就只能够顺序排序了。

还有一种情况就是，旋转部分的长度为0。换句话来说，这个数组就是排序后的数组，这会使得前面的\*p1>\*p2的假设不成立。
但是实际上看到这种情况的时候我们应该偷着乐，因为对于排序后的数组，数组的首元素就是最小值。

完成。


## 依赖
STL库.std::vector.

